<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>汇编</title>
    <link href="/2021/04/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <url>/2021/04/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机的基本结构"><a href="#计算机的基本结构" class="headerlink" title="计算机的基本结构"></a>计算机的基本结构</h2><p>5种功能部件：中央处理器、内部存储器、系统总线、设备接口、外部设备</p><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p>英文全称Center Process Unit，简称CPU。</p><p>功能如下：</p><ol><li><strong>读取、解释、执行机器指令</strong>。</li><li><strong>与内部存储器、设备接口交换信息</strong>。</li><li><strong>执行除指令外的其他时序过程</strong>。</li><li><strong>完成算数逻辑运算</strong>。</li><li><strong>提供少量存储单元</strong>。</li></ol><h3 id="内部存储器"><a href="#内部存储器" class="headerlink" title="内部存储器"></a>内部存储器</h3><p>内存中存放<strong>指令序列</strong>和<strong>用于运算的各种数据</strong></p><p>内部存储器对应主板上的<strong>内存条</strong></p><p>外部存储器属于<strong>外部设备</strong></p><p>内部存储器中存放的信息可以让CPU立即使用</p><p>可执行程序存放在硬盘上CPU是不会执行的，必须先将其载入到内存，再由CPU执行</p><p>简称<strong>内存</strong></p><h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><p>系统总线是计算机系统的<strong>信息交换枢纽</strong>，供中央处理器、内存和设备接口进行信息交换</p><p>总线分为三组：</p><ol><li>地址总线</li><li>数据总线</li><li>控制总线</li></ol><p>两个部件要想完成信息交换，三者缺一不可</p><p>例如CPU读取内存的过程：</p><ol><li>CPU在<strong>地址总线</strong>上提供内存单元的地址</li><li>CPU在<strong>控制总线</strong>上提供“读”信号</li><li>内存单元执行”读“操作，将指定内存单元的数据取出到<strong>数据总线</strong>上传给CPU</li></ol><h3 id="设备接口"><a href="#设备接口" class="headerlink" title="设备接口"></a>设备接口</h3><p>接口的作用：</p><ol><li>信号转换</li><li>数据缓冲</li><li>与CPU交换信息，使CPU控制外接设备</li><li>可编程</li></ol><h3 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h3><p>略</p><h3 id="计算机系统的储存单元"><a href="#计算机系统的储存单元" class="headerlink" title="计算机系统的储存单元"></a>计算机系统的储存单元</h3><p>分为三类</p><ol><li>寄存器，位于CPU内部</li><li>内存单元</li><li>端口</li></ol><h2 id="8088-amp-8086CPU"><a href="#8088-amp-8086CPU" class="headerlink" title="8088&amp;8086CPU"></a>8088&amp;8086CPU</h2><h3 id="基本结构和工作原理"><a href="#基本结构和工作原理" class="headerlink" title="基本结构和工作原理"></a>基本结构和工作原理</h3><p>8086有16位数据总线，可以一次读取一个字（两个字节）</p><p>8088有8位数据总线，可以一次读取一个字节</p><p>但两者内部能够并行处理的最大二进制数都是十六位</p><h4 id="基本的流水线结构"><a href="#基本的流水线结构" class="headerlink" title="基本的流水线结构"></a>基本的流水线结构</h4><p>CPU内部分为BUI和EU两个组成部分</p><p>BUI，即Bus Interface Unit ，是总线接口单元。主要功能是实现CPU与<strong>系统总线</strong>的信息交换。</p><p>EU，即Execute Unit，是执行单元。主要功能是<strong>解释</strong>并<strong>执行</strong>指令。</p><p>BUI和EU可以同时工作，提高效率。</p><h4 id="指令列队"><a href="#指令列队" class="headerlink" title="指令列队"></a>指令列队</h4><p>位于BUI，是具有多个字节的存储单元</p><p>只要<strong>总线出现空闲</strong>，BUI便开始启动读取指令的时序操作，<strong>直到填满指令列队</strong>为止。</p><p>BUI读取到的指令都存在指令列队中，等待被EU读取，读取顺序为<strong>先入先出</strong></p><p><strong>读取指令</strong>这一时序过程与<strong>执行指令</strong>的时序过程<strong>无关</strong>,其中BUI负责<strong>读取指令</strong>，EU负责<strong>从指令列队中取出指令译码后执行</strong></p><p>指令列队与寄存器不同，不能被机器指令访问，只能由CPU自动管理</p><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>控制器位于EU，是CPU的<strong>控制中心</strong></p><p>产生<strong>控制信号</strong>，包括<strong>作用于CPU内部的控制信号</strong>和<strong>CPU发送到系统总线的控制信号</strong></p><h4 id="地址加法器"><a href="#地址加法器" class="headerlink" title="地址加法器"></a>地址加法器</h4><p>位于BUI模块</p><p>功能是由<strong>逻辑地址</strong>计算<strong>物理地址</strong></p><blockquote><p>物理地址：</p><p>是一个固定长度的二进制无符号数编码。8088/8086通过读/写信号来区分“寄存器”、“内存”和”设备接口“，通过地址来确定在上述三者的具体位置。</p><p>物理地址包括高位地址和地位地址，相当于”栋“和”单元“的关系</p></blockquote><blockquote><p>逻辑地址：</p><p>8088/8086的地址总线宽度为20位，没有寄存器可以存下。所以CPU采用 分段管理方式 ，并使用逻辑地址作为CPU内部的物理地址的表达方式。</p><p>段是指内存中一段连续的存储空间，包含多个连续的字节单元。</p><p>逻辑地址由两个16位的编码组成：段基值 和 偏移量（均为无符号数编码）</p><p>转换关系：</p><p>段基址=段基值*16（左移4位，后补4个0）</p><p>物理地址=段基址+偏移量</p></blockquote><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>位于EU模块</p><p>完成算术运算、逻辑运算</p><p>支持双操作数运算</p><h4 id="总线控制逻辑"><a href="#总线控制逻辑" class="headerlink" title="总线控制逻辑"></a>总线控制逻辑</h4><p>位于BIU模块</p><p>用于控制在适当的时候向总线传递相应信号，或从总线接收相应信号</p><h3 id="8088-8086CPU的寄存器组"><a href="#8088-8086CPU的寄存器组" class="headerlink" title="8088/8086CPU的寄存器组"></a>8088/8086CPU的寄存器组</h3><h4 id="数据寄存器组"><a href="#数据寄存器组" class="headerlink" title="数据寄存器组"></a>数据寄存器组</h4><p>数据寄存器是指用于实现指令功能的寄存器。</p><p>数据寄存器都与CPU内部的局部总线相连，使得他们可以为运算器或其他寄存器提供原始数据，即提供<strong>源操作数</strong></p><table><thead><tr><th>寄存器简写</th><th>寄存器名</th></tr></thead><tbody><tr><td>AX（AL、AH）</td><td>累加器</td></tr><tr><td>BX（BL、BH）</td><td>基址寄存器</td></tr><tr><td>CX（CL、CH）</td><td>计数寄存器</td></tr><tr><td>DX（DL、DH）</td><td>数据寄存器</td></tr></tbody></table><h4 id="段寄存器组"><a href="#段寄存器组" class="headerlink" title="段寄存器组"></a>段寄存器组</h4><p>8088/8086CPU共有4个段寄存器，分别用于保存4个段基值，为生成内存单元的物理地址提供必要条件</p><table><thead><tr><th>寄存器简写</th><th>寄存器名</th><th>功能</th></tr></thead><tbody><tr><td>CS(Code Segment)</td><td>代码段段寄存器</td><td>存放由机器指令组成的程序</td></tr><tr><td>DS(Data Segment)</td><td>数据段段寄存器</td><td>保存变量数据</td></tr><tr><td>SS(Stack Segment)</td><td>堆栈段段寄存器</td><td>保存中断断点、子程序返回点、用户使用堆栈临时保存的数据</td></tr><tr><td>ES(Extra Segment)</td><td>附加段段寄存器</td><td>用于串操作等</td></tr></tbody></table><h4 id="地址指针寄存器组"><a href="#地址指针寄存器组" class="headerlink" title="地址指针寄存器组"></a>地址指针寄存器组</h4><p>用于提供内存单元逻辑地址中的<strong>偏移量</strong>或<strong>构成偏移量的分量</strong>。</p><table><thead><tr><th>寄存器简写</th><th>寄存器名</th><th>与段寄存器的搭配关系</th></tr></thead><tbody><tr><td>BX</td><td>基址寄存器</td><td>默认与DS搭配，可更改</td></tr><tr><td>SP</td><td>堆栈指针寄存器</td><td><em><strong>只能与SS搭配</strong></em></td></tr><tr><td>BP</td><td>基址指针寄存器</td><td>默认与SS搭配，可更改</td></tr><tr><td>SI</td><td>源变址寄存器</td><td>默认与DS搭配，可更改</td></tr><tr><td>DI</td><td>目的变址寄存器</td><td>默认与DS搭配，可更改；在串操作指令中只能与ES搭配</td></tr></tbody></table><p><em><strong>数据寄存器和地址指针寄存器一并称为通用寄存器</strong></em></p><h4 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h4><p>包括<strong>指令指针寄存器IP</strong>和<strong>标志寄存器FR</strong></p><h5 id="指令指针寄存器IP"><a href="#指令指针寄存器IP" class="headerlink" title="指令指针寄存器IP"></a>指令指针寄存器IP</h5><p>指令指针寄存器IP(Instruction Pointer)，该寄存器中保存的是CPU下一条要从<strong>内存</strong>中读取的指令在当前代码段（CS指向的段）中首字节的偏移量。</p><p><strong>IP固定与CS搭配使用</strong>，形成下一条即将被读取指令的逻辑地址</p><p>CPU中的BIU每从内存中读取一条指令后，IP指向的对象都会发生改变，指向下一条将被读取的指令 </p><h5 id="标志寄存器FR"><a href="#标志寄存器FR" class="headerlink" title="标志寄存器FR"></a>标志寄存器FR</h5><p>标志寄存器FR(Flag Register)，用于反映最近一次影响标志位的算术或逻辑运算中，运算过程、运算结果的一些性质</p><p>为16位寄存器，其中有效标志位有9位，分别为</p><table><thead><tr><th>状态标志简写</th><th>状态标志名</th><th>功能</th></tr></thead><tbody><tr><td>CF</td><td>进位寄存器</td><td>执行加、减运算时如果最高位发生进位或借位，则置一</td></tr><tr><td>PF</td><td>奇偶标志位</td><td>执行算数逻辑运算后，如运算结果后8位包含偶个1，则置一</td></tr><tr><td>AF</td><td>辅助进位标志位</td><td>执行加、减运算时如果第三位产生进位或借位，则置一</td></tr><tr><td>ZF</td><td>零值标志位</td><td>运算结果为9，则置一</td></tr><tr><td>SF</td><td>符号标志位</td><td>执行算术逻辑运算指令后，SF标志和运算结果的最高位保持一致</td></tr><tr><td>OF</td><td>溢出标志位</td><td>执行算术指令后，如出现溢出，则置一</td></tr><tr><td>TF</td><td>单步跟踪标志位</td><td>为0时，CPU处于连续执行指令工作模式；为1时，CPU处于单步模式</td></tr><tr><td>IF</td><td>中断使能标志位</td><td>为0时，不会响应任何可屏蔽中断</td></tr><tr><td>DF</td><td>方向标志位</td><td>为0时，串操作指令按照地址递增的方向经行操作；为1时···递减···</td></tr></tbody></table><p>前六个为<strong>状态标志</strong>，后三个为<strong>控制标志</strong></p><h1 id="8086-8088基本指令系统"><a href="#8086-8088基本指令系统" class="headerlink" title="8086/8088基本指令系统"></a>8086/8088基本指令系统</h1><h2 id="汇编指令基本格式"><a href="#汇编指令基本格式" class="headerlink" title="汇编指令基本格式"></a>汇编指令基本格式</h2><p>构成汇编指令的基本元素包括<strong>操作助记符</strong>和<strong>操作数</strong></p><p>前者指明指令的功能，后者指明指令操作的数据</p><h3 id="基本格式——双操作数指令"><a href="#基本格式——双操作数指令" class="headerlink" title="基本格式——双操作数指令"></a>基本格式——双操作数指令</h3><p>MOV    AX，    BX</p><p>MOV是操作助记符；</p><p>AX是目的操作数，代表操作完成的结果数据；</p><p>BX是源操作数，为指令提供原始数据。</p><h3 id="基本格式——单操作数指令"><a href="#基本格式——单操作数指令" class="headerlink" title="基本格式——单操作数指令"></a>基本格式——单操作数指令</h3><p>NOT    AX</p><p>NOT是操作助记符；</p><p>AX既提供原始数据，又可以保存操作结果。</p><h3 id="基本格式——无操作数指令"><a href="#基本格式——无操作数指令" class="headerlink" title="基本格式——无操作数指令"></a>基本格式——无操作数指令</h3><p>NOP</p><p>NOP是操作助记符</p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p><em><strong>寻址方式是指指令获得操作数的方式</strong></em></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数储存在寄存器中，无需访问内存，执行很快</p><p>例：</p><p>MOV    AX，    BX    ;（BX）保存到AX</p><p>ADD    AL,    DL    ;(AL)与(DL)相加后保存在AL</p><h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>操作数包含在机器指令内，无需访问内存，执行很快</p><p>例：</p><p>MOV    AL,    25    将25保存到AL</p><h3 id="存储器寻址方式"><a href="#存储器寻址方式" class="headerlink" title="存储器寻址方式"></a>存储器寻址方式</h3><p>操作数在内存单元内，执行较慢</p><p>在内存单元中寻址需要知道物理地址，物理地址由<strong>逻辑地址</strong>转换而来，逻辑地址由<strong>段基值</strong>和<strong>偏移量</strong>构成。</p><p>偏移量有多种获取方式，不同的获取方式形成不同的储存器寻址方式。</p><p>内存单元的偏移量由三种不同的偏移分量构成，它们分别是：</p><ol><li>机器指令位移量字段提供的位移量</li><li>基址寄存器提供的基址分量</li><li>变址寄存器提供的变址分量</li></ol><p>偏移量又称<strong>有效地址(effective address)</strong>,简称<strong>EA</strong>。</p><h5 id="直接寻址方式"><a href="#直接寻址方式" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h5><p>直接使用机器指令中位移量字段中的位移量作为内存操作数的偏移量</p><p><em><strong>EA=DISP</strong></em></p><p>DISP是指disparity，即位移量</p><p>例：</p><p>MOV    AL,    [1000H]</p><p>这条指令忽略了段基值，默认使用DS提供段基值</p><p>MOV    ES:[0100H],    BX</p><p>这条指令指明使用ES提供段基值</p><p>MOV    VAR1,    BL</p><p>这条指令中的VAR1是一个变量名，实质为<strong>符号位移量</strong>，在会汇编后将被替换成数值位移量，二者在实质上是相同的。同样的这条指令忽略的段基值，由DS提供</p><p>MOV    VAR1+2,    AL</p><p>这条指令的目标操作数的VAR1后面有一个“+2”，表示偏移量为VAR1+2.</p><h5 id="寄存器间接寻址方式"><a href="#寄存器间接寻址方式" class="headerlink" title="寄存器间接寻址方式"></a>寄存器间接寻址方式</h5><p>内存操作数的偏移量由地址指针寄存器BX、BP、SI、DI<strong>其中之一</strong>提供，则称该操作数为<strong>寄存器间接寻址方式</strong></p><p>其中BX、BP提供的是<strong>基址分量</strong></p><p>SI、DI提供的是<strong>变址分量</strong></p><table><thead><tr><th>寄存器简写</th><th>寄存器名</th><th>与段寄存器的搭配关系</th></tr></thead><tbody><tr><td>BX</td><td>基址寄存器</td><td>默认与DS搭配，可更改</td></tr><tr><td>SP</td><td>堆栈指针寄存器</td><td><em><strong>只能与SS搭配</strong></em></td></tr><tr><td>BP</td><td>基址指针寄存器</td><td><strong>默认与SS搭配</strong>，可更改</td></tr><tr><td>SI</td><td>源变址寄存器</td><td>默认与DS搭配，可更改</td></tr><tr><td>DI</td><td>目的变址寄存器</td><td>默认与DS搭配，可更改；在串操作指令中只能与ES搭配</td></tr></tbody></table><p>例：</p><p>ADD    CL,    [BX]</p><p>SUB    ES:[SI],    AX</p><h5 id="基址寻址与变址寻址"><a href="#基址寻址与变址寻址" class="headerlink" title="基址寻址与变址寻址"></a>基址寻址与变址寻址</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2021/04/10/C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/04/10/C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><h2 id="C-概述"><a href="#C-概述" class="headerlink" title="C++概述"></a>C++概述</h2><p>C++是一种面向对象的编程语言，由C语言发展而来。</p><h2 id="C-对C的补充"><a href="#C-对C的补充" class="headerlink" title="C++对C的补充"></a>C++对C的补充</h2><h3 id="新的输入输出方式"><a href="#新的输入输出方式" class="headerlink" title="新的输入输出方式"></a>新的输入输出方式</h3><h4 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h4><p>运算符<code>&lt;&lt;</code> 用于输出，称为插入运算符，意思是将输出内容插入到输出流中。</p><p>说明</p><ol><li><code>&lt;&lt;</code> 可以连续使用。</li><li>对于一般的指针，<code>&lt;&lt;</code> 输出其指针值；对于字符型指针，<code>&lt;&lt;</code> 输出其所指向的字符串。</li><li>可以直接输出字符串常量。</li><li>用<code>endl</code> 表示换行。</li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">char</span> c=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">float</span> f=<span class="hljs-number">20.325</span>;<br>    <span class="hljs-keyword">int</span> *pi=&amp;i;<br>    <span class="hljs-keyword">char</span> *pa=<span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    cout&lt;&lt;i&lt;&lt;&#x27;/t&#x27;&lt;&lt;c&lt;&lt;&#x27;/t&#x27;&lt;&lt;f&lt;&lt;endl;<br>    cout&lt;&lt;pi&lt;&lt;&#x27;/t&#x27;&lt;&lt;pa&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;这是一个字符串常量！&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">10a20</span><span class="hljs-string">.</span><span class="hljs-comment">325</span><br><span class="hljs-comment">0012ff38Hello</span> <span class="hljs-comment">World!</span><br><span class="hljs-comment">这是一个字符串常量！</span><br></code></pre></td></tr></table></figure><h4 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h4><p>运算符<code>&gt;&gt;</code> 用于输入，称为提取运算符。意思是从输入流中抽取一个数据。</p><p>同样的，可以连续使用。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">float</span> f;<br>    cin&gt;&gt;i&gt;&gt;c&gt;&gt;f;<br>    cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; c=&quot;</span>&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot; f=&quot;</span>&lt;&lt;f;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>a<span class="hljs-number">30</span>.<span class="hljs-number">89</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">i</span>=10 <span class="hljs-attribute">c</span>=a <span class="hljs-attribute">f</span>=30.89<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>cin为缓冲流。键盘键入的数据保存在缓冲区中，cin实际是从缓冲区提取数据。如果一次输入数据过多，会滞留在缓冲区中，影响下一次输入。</li><li>输入的数据应与数据类型相同。</li><li>空格、回车都可以作为数据之间的分隔符；多个数据可以在同一行输入，也可在不同行输入对于字符型数据和字符串，空格无法用cin输入，字符串中也不能有空格；回车符也无法读入。</li></ol><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i;<br>cin&gt;&gt;i;<br></code></pre></td></tr></table></figure><p>intput:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">W</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>则<code>i</code>的值<strong>不是</strong>20，cin自动跳过前面的分隔符，遇到第一个非空白字符为W，它无法转化为整形，故读取失败。</p><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>cin&gt;&gt;s;<br></code></pre></td></tr></table></figure><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">123 </span>  <span class="hljs-number">456</span><br></code></pre></td></tr></table></figure><p><code>s</code> 的内容为<code>123</code></p><h3 id="注释、变量声明与作用域限定符"><a href="#注释、变量声明与作用域限定符" class="headerlink" title="注释、变量声明与作用域限定符"></a>注释、变量声明与作用域限定符</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*...*/</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h4 id="随时随地声明变量"><a href="#随时随地声明变量" class="headerlink" title="随时随地声明变量"></a>随时随地声明变量</h4><p>C语言中变量声明必须在可执行代码前，C++则可以在任何地方声明。</p><h4 id="作用域限定符”：：“"><a href="#作用域限定符”：：“" class="headerlink" title="作用域限定符”：：“"></a>作用域限定符”：：“</h4><p>格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">限定符::成员名<br></code></pre></td></tr></table></figure><p>限定符可以被省略，此时说明<code>::</code> 后的成员为全局变量</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#iostream<span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">20</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;局部变量i=&quot;</span>&lt;&lt;i;<br>    cout&lt;&lt;<span class="hljs-string">&quot; 全局变量i=&quot;</span>&lt;&lt;::i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>outcome:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">局部变量<span class="hljs-attribute">i</span>=20 全局变量<span class="hljs-attribute">i</span>=10<br></code></pre></td></tr></table></figure><h3 id="强制类型转换与从上图标识符"><a href="#强制类型转换与从上图标识符" class="headerlink" title="强制类型转换与从上图标识符"></a>强制类型转换与从上图标识符</h3><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>C语言</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">char</span> c=(<span class="hljs-keyword">char</span>)i;<br></code></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">char</span> c=<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(i);<br></code></pre></td></tr></table></figure><p>两者均可用</p><h4 id="const常量标识符"><a href="#const常量标识符" class="headerlink" title="const常量标识符"></a>const常量标识符</h4><p>注意：</p><p>（1）常量定义时必须初始化</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">5</span>;<br>i=<span class="hljs-number">10</span>;<span class="hljs-comment">//wrong</span><br>i++;<span class="hljs-comment">//wrong</span><br></code></pre></td></tr></table></figure><p>（2）const为右结合，若是简单数据类型，可以写在数据类型左侧</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> j=<span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>（3）可以在任何地方定义，其作用域随位置不同而不同。</p><h3 id="函数原型声明"><a href="#函数原型声明" class="headerlink" title="函数原型声明"></a>函数原型声明</h3><p>如函数调用位置在函数定义之前，则应在调用前声明函数原型，这样编译系统可以对函数调用的合法性经行检查，以保证程序运行的正确性。</p><p>函数原型声明语法如下：</p><p>​    函数返回类型 函数名 （参数表）;</p><p>注意：</p><p>（1）每个参数之间用逗号相隔。</p><p>（2）可以只声明参数类型，不给出参数名，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p1,*p2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *,<span class="hljs-keyword">int</span> *)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>函数调用需要耗费一定时间，如果一个函数需要频繁调用，那么将消耗大量时间，从而降低程序运行效率。C++提供内联函数来减少函数调用所需消耗的时间，即将函数的代码嵌入到每一个调用处，虽然这样会使程序边长，但它可以避免调用函数。</p><p>声明内联函数很简单，只需在函数返回类型前加关键字<code>inline</code> 即可。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        cout&lt;&lt;<span class="hljs-built_in">Add</span>(i,i)&lt;&lt;<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">20</span><span class="hljs-number">18</span><span class="hljs-number">16</span><span class="hljs-number">14</span><span class="hljs-number">12</span><span class="hljs-number">10</span><span class="hljs-number">8</span><span class="hljs-number">6</span><span class="hljs-number">4</span><span class="hljs-number">2</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>注意：使用内联函数虽然可以减小时间的开销，但会增加程序长度，一次，<code>inline</code> 关键字只适用于<strong>短小且频繁调用的</strong>函数。</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>C语言规定，在同一作用域中不能有同名函数存在。与之相反，C++允许在同一作用域中用同一函数名定义多个函数。</p><p>在这些函数中，函数的参数的个数、类型、顺序不尽相同。编译器会根据实参和形参的最佳匹配来确定调用哪一个函数。这就是函数的重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b&gt;a) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a,<span class="hljs-keyword">float</span> b,<span class="hljs-keyword">float</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b&gt;a) a=b;<br>    <span class="hljs-keyword">if</span>(c&gt;a) a=c;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-keyword">float</span> c,d,e;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cin&gt;&gt;c&gt;&gt;d&gt;&gt;e;<br>    <span class="hljs-keyword">int</span> m;<br>    m=<span class="hljs-built_in">Max</span>(a,b);<br>    cout&lt;&lt;<span class="hljs-string">&quot;Max_int=&quot;</span>&lt;&lt;m&lt;&lt;endl;<br>    <span class="hljs-keyword">float</span> n=<span class="hljs-built_in">Max</span>(c,d,e);<br>    cout&lt;&lt;<span class="hljs-string">&quot;Max_float=&quot;</span>&lt;&lt;n&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">56 </span><span class="hljs-number">90</span><br><span class="hljs-number">23.2</span> <span class="hljs-number">30.5</span> <span class="hljs-number">1.4</span><br></code></pre></td></tr></table></figure><p>output</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Max_int</span>=<span class="hljs-number">90</span><br><span class="hljs-attr">Max_float</span>=<span class="hljs-number">30.5</span><br></code></pre></td></tr></table></figure><p>注意：重载函数的参数类型、个数和顺序<strong>至少有一个</strong>不同；函数返回类型可以相同也可以不同。</p><h3 id="带默认参数的函数"><a href="#带默认参数的函数" class="headerlink" title="带默认参数的函数"></a>带默认参数的函数</h3><p>函数调用的时候要将实参传递给形参，一般情况下实参的个数应与形参个数相同。有时也会出现多次用相同实参调用同一个函数的情况。C++为此提供简化方式：</p><p>例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void <span class="hljs-builtin-name">Set</span>(int <span class="hljs-attribute">i</span>=0)<br></code></pre></td></tr></table></figure><p>若不传递实参调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Set</span><span class="hljs-params">()</span></span><span class="hljs-comment">//此时相当于调用Set(0)</span><br></code></pre></td></tr></table></figure><p>也可以传递实参调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br></code></pre></td></tr></table></figure><p>注意：若有多个实参，则默认参数必须在最右边</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int a,int b,int c=<span class="hljs-number">10</span>)</span></span><span class="hljs-comment">//合法</span><br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int a,int c=<span class="hljs-number">10</span>,int b)</span></span><span class="hljs-comment">//不合法</span><br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是C++一种数据类型，即给变量起另一个名字，以便在需要时间接引用该变量。对一个变量引用所做的所有操作，都是对该变量本身的操作。引用运算符使用<code>&amp;</code> 。</p><p>声明一个引用的语法如下：</p><p>​    &lt;类型标识符&gt;&amp;&lt;引用名&gt;=&lt;变量名&gt;</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> &amp;j=i;<br></code></pre></td></tr></table></figure><p>注意：<br>（1）引用在声明时必须初始化，即指定它指向哪个变量。</p><p>（2）引用变量一经初始化，就不能再引用别的变量。</p><p>（3）运算符<code>&amp;</code> 只有在其前面有类型符相连时才代表“引用”，否则代表“取地址”。</p><p>（4）系统不会为变量的引用另外分配储存空间，引用和被引用变量共享同一内存单元。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> &amp;j=i;<br>    cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j&lt;&lt;endl;<br>    j++;<br>    i++;<br>    cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">i</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">j</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">i</span>=<span class="hljs-number">12</span><br><span class="hljs-attr">j</span>=<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><h3 id="运算符new和delete"><a href="#运算符new和delete" class="headerlink" title="运算符new和delete"></a>运算符new和delete</h3><h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><p>new操作符格式如下：</p><p>（1）指针变量=new 类型；</p><p>（2）指针变量=new 类型（初值）；</p><p>（3）指针变量=new 类型[数组元素数]。</p><p>new的返回值：若是非数组类型，返回指向该类型对象的指针；若是数组类型，返回数组的首地址。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p;<br>p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<span class="hljs-comment">//动态内存分配</span><br>*p=<span class="hljs-number">3</span>;<span class="hljs-comment">//第二、三行可以合并成：p=new int(3);</span><br><span class="hljs-keyword">float</span> *pl;<br>pl=<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//为三个元素的float数组申请堆内存</span><br>pl[<span class="hljs-number">2</span>]=<span class="hljs-number">20.9</span>;<span class="hljs-comment">//为数组第三个元素赋值</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>（1）new申请内存不一定总会成功，不成功时返回NULL。程序应注意判断new操作符的返回值，只有在非NULL的情况下才能进行访问。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p;<br>p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<br>&#123;<span class="hljs-comment">//申请到内存</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<span class="hljs-comment">//申请失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）new为数组分配内存时无法提供初值。</p><p>（3）new为二维数组分配堆内存可以按以下方式进行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> m=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> **p;<br>p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>* [m];<span class="hljs-comment">//第一维，分配m行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>&#123;<br>    p[i]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n];<span class="hljs-comment">//第二维，为每行分配n给元素</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="delete操作符"><a href="#delete操作符" class="headerlink" title="delete操作符"></a>delete操作符</h4><p>delete操作符格式：</p><p>（1）delete 指针变量；        //释放指针变量所指向的堆内存</p><p>（2）delete []指针变量；     //释放为数组分配的堆内存</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//释放p指向的堆内存</span><br><br><span class="hljs-keyword">delete</span> []p;<span class="hljs-comment">//释放p数组分配的内存</span><br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)<span class="hljs-comment">//释放二维数组分配的内存</span><br>&#123;<br><span class="hljs-keyword">delete</span> [] p[i]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：new申请的堆内存在用完后必须用delete释放‘</strong></p><h2 id="C-程序的开发过程"><a href="#C-程序的开发过程" class="headerlink" title="C++程序的开发过程"></a>C++程序的开发过程</h2><h3 id="一个简单的C-程序"><a href="#一个简单的C-程序" class="headerlink" title="一个简单的C++程序"></a>一个简单的C++程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">/*****************************************</span><br><span class="hljs-comment"> *(1)编译预处理命令</span><br><span class="hljs-comment"> *   所有预处理命令都以“#”引导</span><br><span class="hljs-comment"> *   每条预处理命令单独占一行</span><br><span class="hljs-comment"> *   不以“；”结束                          </span><br><span class="hljs-comment"> *****************************************/</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*****************************************</span><br><span class="hljs-comment"> *(2)针对命名空间的命令</span><br><span class="hljs-comment"> *****************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><span class="hljs-comment">//主函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Hello World!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-程序的开发"><a href="#C-程序的开发" class="headerlink" title="C++程序的开发"></a>C++程序的开发</h3><p>（1）程序编辑</p><p>​            编写程序源码并将其输入到计算机中，生成拓展名为.cpp的磁盘文件</p><p>（2）程序编译</p><p>​            将源代码通过编译器转换为机器语言代码，生成拓展名为.obj的目标文件</p><p>（3）程序连接</p><p>​            将多个目标文件和系统提供的库文件中的某些文件连接在一起，生成一个拓展名为.exe的可执行文件</p><p>（4）程序运行</p><h1 id="C-类和对象"><a href="#C-类和对象" class="headerlink" title="C++类和对象"></a>C++类和对象</h1><h2 id="面向对象程序设计方法概述"><a href="#面向对象程序设计方法概述" class="headerlink" title="面向对象程序设计方法概述"></a>面向对象程序设计方法概述</h2><h3 id="面对对象程序设计方法的基本概念"><a href="#面对对象程序设计方法的基本概念" class="headerlink" title="面对对象程序设计方法的基本概念"></a>面对对象程序设计方法的基本概念</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象是人研究的任何事物，包含两个要素——属性和行为。</p><p>例如研究对象是学生张三，其属性包括：姓名、性别、年龄、学号、成绩······其行为可以包括：添加一个学生，更改学号，添加成绩······</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>具有相同属性和行为的对象的抽象就是<strong>类</strong>。</p><p>例如许多像张三一样的学生就是学生类。</p><h4 id="方法和消息"><a href="#方法和消息" class="headerlink" title="方法和消息"></a>方法和消息</h4><p>类中行为的实现过程即类的方法，也是类的成员函数。一个方法包括方法名（函数名）、返回值类型、参数表和方法体（函数体）。</p><p>对象之间通过发送消息来实现相互沟通。向对象发送一条消息时至少要包括接收消息的对象名、对象需执行行为的名称（方法名）也许还有调用方法的参数。</p><h3 id="面向对象程序设计方法的基本原理"><a href="#面向对象程序设计方法的基本原理" class="headerlink" title="面向对象程序设计方法的基本原理"></a>面向对象程序设计方法的基本原理</h3><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>从众多的事物中抽取出共同的、本质的特征就是抽象。</p><p>抽象是简化问题的途径，它可以为具体问题找到最恰当的类定义。</p><p>抽象时要忽略无关信息。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>把对象的属性和行为结合成一个独立的单位，尽可能隐藏对象的内部细节。</p><p>有两层含义：</p><ol><li>把对象的全部属性和行为结合在一起，形成一个不可分割的独立单位，对象的属性值只能由这个对象的行为来读取和修改。</li><li>在对象的内部和外部之间形成一道屏障，内部与外部的联系只能通过外部接口实现。</li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h4 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h4><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类是C++语言的一种抽象和封装机制,它描述了一种具有相同属性和行为的对象</p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>将对象的属性抽象为数据成员，将对象的行为抽象为成员函数，并对他们经行封装，就由此形成了类。</p><p>类的定义格式一般分为声明部分和实现部分。</p><p>声明部分是用来声明该类的成员，包括数据成员的声明和成员函数的声明。所谓成员函数的声明，就是只声明成员函数的函数原型，而成员函数的实现则是对成员函数经行定义。</p><p>类的一般定义格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span>&lt;</span>name&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    &lt;成员函数或数据成员的声明&gt;<br>    <span class="hljs-keyword">private</span>:<br>    &lt;数据成员或成员函数的声明&gt;<br>&#125;;<br>&lt;各个成员函数的类外实现&gt;<br></code></pre></td></tr></table></figure><ol><li>class是定义类的关键字，<name>是标识符</li><li>{}内是声明部分，包含描述属性的数据成员和定义行为的成员函数的函数原型</li><li>关键字public、private和protected被称为访问限制符，说明成员的访问权限</li><li>成员函数一般被列为公有成员，为外界提供操作接口，便于访问和</li><li>应用数据成员一般被列为私有成员，因为类的数据必须是封装的，不能随便取用</li><li>&lt;各个成员函数的类外实现&gt;是类的实现部分</li></ol><p>下面给出一个日期类定义的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//文件路径名：s2_1\sclass2_1_date.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> d)</span></span><br><span class="hljs-function">    </span>&#123;<br>        year = y;<br>        month = m;<br>        day = d;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsLeapYear</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span>(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>)||(year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;year&lt;&lt;<span class="hljs-string">&quot;年&quot;</span>&lt;&lt;month&lt;&lt;<span class="hljs-string">&quot;月&quot;</span>&lt;&lt;day&lt;&lt;<span class="hljs-string">&quot;日&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> year;<br>    <span class="hljs-keyword">int</span> month;<br>    <span class="hljs-keyword">int</span> day;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;sclass2_1_date.h.&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Date d1;<br>    d1.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2012</span>,<span class="hljs-number">11</span>,<span class="hljs-number">11</span>);<br>    d1.<span class="hljs-built_in">Print</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;此年是闰年吗？:&quot;</span>&lt;&lt;d1.<span class="hljs-built_in">IsLeapYear</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2012</span>年<span class="hljs-number">11</span>月<span class="hljs-number">11</span>日此年是闰年吗？：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>一般规定：</strong></p><ol><li>在类体中先声明类的行为，后声明类的属性</li><li>一般按数据成员类型的大小，由小到大声明，这样可以提高空间利用率</li></ol><h3 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h3><p>类的核心是<strong>成员函数</strong>，而成员函数的核心是<strong>算法</strong>。因此算法的程序实现就是成员函数的实现，即“类的实现”。</p><p>成员函数的实现一般有两种方式：<strong>类内实现</strong>，和<strong>类外实现</strong></p><p><strong>类内实现</strong>指每一个成员函数在声明时就定义了代码。</p><p><strong>类外实现</strong>指把实现成员函数的代码放在类外。</p><p>例如把前一个例子的声明精简如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> d)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsLeapYear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> year;<br>    <span class="hljs-keyword">int</span> month;<br>    <span class="hljs-keyword">int</span> day;<br>&#125;;<br></code></pre></td></tr></table></figure><p>建议将声明内容单独放在一个头文件（拓展名.h）中，实现部分放在一个源文件（拓展名为.cpp）里。</p><p><strong>上面为声明部分，下面为实现部分</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Date::SetDate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    year = y;<br>    month = m;<br>    day = d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Date::IsLeapYear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span>(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>)||(year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Date::Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;year&lt;&lt;<span class="hljs-string">&#x27;.&#x27;</span>&lt;&lt;month&lt;&lt;<span class="hljs-string">&#x27;.&#x27;</span>&lt;&lt;day&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>类名 对象名;</strong></p><p>或</p><p><strong>类名 对象1，对象2；</strong></p><p>如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Date newDate;<span class="hljs-comment">//方法一</span><br>Date newDate1,newDate2;<span class="hljs-comment">//方法二</span><br></code></pre></td></tr></table></figure><p>由于Date类没有为对象初始化，所以以上每个对象的年月日在对象创建时由系统<strong>随机</strong>初始化。</p><p>创建对象的代码要写在main()中，并将main()单独放在一个源文件（.cpp）中</p><h3 id="类成员的访问"><a href="#类成员的访问" class="headerlink" title="类成员的访问"></a>类成员的访问</h3><h4 id="类成员的一般访问形式"><a href="#类成员的一般访问形式" class="headerlink" title="类成员的一般访问形式"></a>类成员的一般访问形式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">对象名.数据成员名;<br>对象名.成员函数名(参数表);<br></code></pre></td></tr></table></figure><h4 id="类成员的访问权限"><a href="#类成员的访问权限" class="headerlink" title="类成员的访问权限"></a>类成员的访问权限</h4><p>共有三中访问权限</p><ol><li><strong>public</strong>代表公有的访问权限。它修饰了类对外公开的部分，凡是由public声明的成员被称为<strong>公有成员</strong>，<strong>允许类外访问</strong>。</li><li><strong>private</strong>代表私有的访问权限，它规定了只能被<strong>类内部的成员函数</strong>访问的部分，任何类外的访问都是非法的。private像一道屏障，把它所修饰的成员与外部分隔开实现数据隐藏，在最大程度上保护了类的私有数据。</li><li><strong>protected</strong>代表保护的访问权限。它与私有的访问权限类似，曲别在于保护权限的成员不仅可以被本类的成员函数访问，还可以被派生类的成员访问。</li></ol><p>注意：</p><ol><li>不同权限的成员可以以任意顺序声明。</li><li>如果<strong>私有成员</strong>类在最前面，可以省略关键字<code>private</code>,因为它是默认的访问限制符。</li></ol><p>例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//文件路径名：s2_2\sclass2_2_cdemo.h    // sclass2_2_cdemo.h文件开始</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __SCLASS2_2_CDEMO_H__</span><br><span class="hljs-comment">// 如果未定义__SCLASS2_2_CDEMO_H__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __SCLASS2_2_CDEMO_H__</span><br><span class="hljs-comment">// 则定义__SCLASS2_2_CDEMO_H__,继续编译后面的语句,直到遇到#endif</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><br><span class="hljs-comment">//CDemo类的定义     </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDemo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetI</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span>                 <span class="hljs-comment">//设置外部接口SetI( )为i赋值</span></span><br><span class="hljs-function"></span>&#123;<br>i = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetJ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> <span class="hljs-comment">//设置外部接口SetJ( )为j赋值</span></span><br><span class="hljs-function"></span>&#123;<br>j = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetI</span><span class="hljs-params">( )</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl;     <span class="hljs-comment">//输出i的值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetJ</span><span class="hljs-params">( )</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;j=&quot;</span> &lt;&lt; j &lt;&lt; endl;     <span class="hljs-comment">//输出j的值</span><br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">int</span> j;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> i;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span><span class="hljs-comment">// sclass2_2_cdemo.h文件结束</span></span><br><br><br><span class="hljs-comment">// 文件路径名:s2_2\smain2_2.cpp  // smain2_2.cppsmain2_2.cpp文件开始</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;sclass2_2_cdemo.h.&quot;</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CDemo d; <span class="hljs-comment">//创建一个Demo类对象 </span><br>d.<span class="hljs-built_in">SetI</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//调用SetI( ) 间接访问私有数据i并为i赋值为10</span><br>d.<span class="hljs-built_in">SetJ</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">//调用SetJ( ) 间接访问私有数据j并为i赋值为20</span><br><span class="hljs-comment">// d.i ＝10;       // 非法！</span><br><span class="hljs-comment">// d.j ＝20;       // 非法！</span><br>d.<span class="hljs-built_in">GetI</span>( ); <span class="hljs-comment">//调用GetI( )间接访问私有数据i并输出其值</span><br>d.<span class="hljs-built_in">GetJ</span>( ); <span class="hljs-comment">//调用GetJ( )间接访问私有数据j并输出其值</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// smain2_2.cpp文件结束</span><br><br></code></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数为对象在被创建时<strong>分配内存空间</strong>，利用给定的值去<strong>初始化对象的数据成员</strong>，把对象构造成一个特定的状态。</p><p>声明构造函数的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>类名(参数表);<br></code></pre></td></tr></table></figure><p>构造函是类的一个特殊函数，如果一个类没有人为构造函数，那么系统会自动生成一个<strong>不带参数</strong>的默认构造函数。</p><p><em><strong>构造函数名就是类名，无返回值</strong></em></p><h3 id="重载构造函数"><a href="#重载构造函数" class="headerlink" title="重载构造函数"></a>重载构造函数</h3><p>可以在一个类中定义多个构造函数，即重载函数</p><p>例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//构造函数1</span><br>    <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> d);<span class="hljs-comment">//构造函数2</span><br>    <span class="hljs-comment">/*以下略*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="带默认参数的构造函数"><a href="#带默认参数的构造函数" class="headerlink" title="带默认参数的构造函数"></a>带默认参数的构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">2021</span>,m=<span class="hljs-number">4</span>,d=<span class="hljs-number">8</span>);<br>    <span class="hljs-comment">/*略*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>用来复制对象的一种特殊构造函数，格式如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span>:<br>类名(<span class="hljs-keyword">const</span> 类名&amp;对象名)；<br></code></pre></td></tr></table></figure><p>注意</p><ol><li>拷贝构造函数名就是类名</li><li>没有返回类型</li><li>有且只有一个参数</li><li>const用于约束参数不变</li><li>参数采用引用方法传递可以减少内存空间的占用，减少系统开销</li><li>不含指针的类可以使用系统自动生成的拷贝构造函数经行<strong>浅拷贝</strong></li><li>含指针的类有必要定义一个<strong>深度拷贝构造函数</strong>，先申请内存空间再经行内容的复制</li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cpoint</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">cpoint</span>(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> y1);<br><span class="hljs-built_in">cpoint</span>(<span class="hljs-keyword">const</span> cpoint &amp;obj);<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span>;<br>~<span class="hljs-built_in">cpoint</span>()&#123;&#125;;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br>&#125;;<br><br>cpoint::<span class="hljs-built_in">cpoint</span>(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> y1)<br>&#123;<br>x=x1;<br>y=y1;<br>&#125;<br><br>cpoint::<span class="hljs-built_in">cpoint</span>(<span class="hljs-keyword">const</span> cpoint &amp;obj)<br>&#123;<br>x=obj.x;<br>y=obj.y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cpoint::getX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cpoint::getY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cpoint.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">cpoint <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">cpoint <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;<br>cpoint c=b;<br>cout&lt;&lt;<span class="hljs-string">&quot;a(&quot;</span>&lt;&lt;a.<span class="hljs-built_in">getX</span>()&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;a.<span class="hljs-built_in">getY</span>()&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;b(&quot;</span>&lt;&lt;b.<span class="hljs-built_in">getX</span>()&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;b.<span class="hljs-built_in">getY</span>()&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;c(&quot;</span>&lt;&lt;c.<span class="hljs-built_in">getX</span>()&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;c.<span class="hljs-built_in">getY</span>()&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>经行对象的清理工作</p><p>格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>~类名();<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>析构函数名与类名相同，前面多家一个“~”</li><li>无返回值和参数，不能重载</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++Primer1</title>
    <link href="/2021/04/10/C++Primer/"/>
    <url>/2021/04/10/C++Primer/</url>
    
    <content type="html"><![CDATA[<h1 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h1><ol><li><code>win+r</code>打开运行，输入<code>cmd</code>打开DOS窗口</li><li><code>exit</code>命令退出当前DOS窗口</li><li><code>cls</code>清屏</li><li><code>dir</code>列出当前目录下的所有子文件/子目录</li><li><code>cd</code>命令。（1）表示change directry 改变路径（2）用法：<code>cd 目录的路径</code>（3）路径可以是相对路径也可以是绝对路径</li><li><code>cd..</code>回到上级目录</li><li><code>cd\</code>回到根目录</li><li><code>D:</code>切换盘符</li></ol><h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><h4 id="2-1-1算术类型"><a href="#2-1-1算术类型" class="headerlink" title="2.1.1算术类型"></a>2.1.1算术类型</h4><p>算术类型分为两类，即<strong>整型</strong>和<strong>浮点型</strong></p><blockquote><p>此处有一个表格</p></blockquote><p>整型包括<strong>有符号型</strong>和<strong>无符号型</strong></p><h4 id="2-1-2类型转换"><a href="#2-1-2类型转换" class="headerlink" title="2.1.2类型转换"></a>2.1.2类型转换</h4><ol><li>当我们把一个非布尔型的算数值赋给布尔型时，初始值为0则结果为false，否则结果为true。</li><li>当我们把一个布尔值赋给非布尔值时，初始值为false，则结果为0，否则为1。</li><li>当我们把一个浮点数赋给整型时，进行了近似处理。结果仅保留浮点数的整数部分。</li><li>当我们把一个整数赋给浮点类型时，小数部分记为0.如果整数部分超过了浮点类型的容量，精度可能有损失。</li><li>当我们赋给无符号类型一个超出它表示范围的值时，结果是<strong>初始值对无符号类型表示数值总数取模后的余数</strong>。</li><li>当我们赋给一个类型超出它表示范围的值时，结果是未定义的。</li></ol><h4 id="2-1-3字面量常量"><a href="#2-1-3字面量常量" class="headerlink" title="2.1.3字面量常量"></a>2.1.3字面量常量</h4><p>整型字面量的具体数据类型由它的值和符号决定。十进制字面量是带符号数，八进制和十六进制数既可以是带符号数也可以是无符号数。</p><p>十进制字面量的类型是int、long int、long long int中尺寸最小的那个。</p><p>八进制和十六进制的类型是int\long int\long long int\unsigned int····中最小的那一个。</p><p>字符和字符串字面量略</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> a = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> a&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="符合类型"><a href="#符合类型" class="headerlink" title="符合类型"></a>符合类型</h3><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h3 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h3><h2 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h2><h3 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h3><p>格式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::name;<br></code></pre></td></tr></table></figure><p>注意：<strong>头文件不应包含using声明</strong></p><h3 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h3><p><strong>string</strong>类型表示 <em>可变长</em>  的字符序列</p><p>使用时应包含</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br></code></pre></td></tr></table></figure><h4 id="3-2-1定义和初始化string对象"><a href="#3-2-1定义和初始化string对象" class="headerlink" title="3.2.1定义和初始化string对象"></a>3.2.1定义和初始化string对象</h4><p>定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br></code></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s1=s2;<br>string s=<span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//拷贝初始化</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">ss</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">sss</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="3-2-2string对象的操作"><a href="#3-2-2string对象的操作" class="headerlink" title="3.2.2string对象的操作"></a>3.2.2string对象的操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">s1+s2;<span class="hljs-comment">//返回s1和s2连接的结果</span><br><span class="hljs-built_in">getline</span>(is,s);<span class="hljs-comment">//将一行的信息读到s中</span><br>s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回s的长度</span><br>s.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//如果s为空，则返回1；否则返回0</span><br></code></pre></td></tr></table></figure><p>注意：<code>s.size</code>的返回类型是string::size_type，建议这样使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> len=s.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><p>string对象可以相互比较，并对大小写敏感。</p><p>字面量值可以和string对象相加，但两个字面量值不能相加，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s1=<span class="hljs-string">&quot;hello&quot;</span>,s2=<span class="hljs-string">&quot;world&quot;</span>,s3;<br>s3=s1+<span class="hljs-string">&quot; &quot;</span>+s2;<span class="hljs-comment">//正确</span><br>s3=<span class="hljs-string">&quot;hello&quot;</span>+<span class="hljs-string">&quot; &quot;</span>+s2;<span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><h4 id="3-2-3处理string中的字符"><a href="#3-2-3处理string中的字符" class="headerlink" title="3.2.3处理string中的字符"></a>3.2.3处理string中的字符</h4><p>基于范围的for语句</p><p>格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(declaration:expression)<br>statement<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)<br>    cout&lt;&lt;c&lt;&lt;endl;<br><span class="hljs-comment">//将s中的每个字符每行一个输出出来，没有改变s中的字符</span><br></code></pre></td></tr></table></figure><p>再例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:s)<br>    c=<span class="hljs-built_in">toupper</span>(c);<br>cout&lt;&lt;s&lt;&lt;endl;<br><span class="hljs-comment">//将s中的每个字母变成大写</span><br></code></pre></td></tr></table></figure><p>可以使用下标取值</p><h3 id="3-3标准库类型vector"><a href="#3-3标准库类型vector" class="headerlink" title="3.3标准库类型vector"></a>3.3标准库类型vector</h3><p>vector表示对象的集合</p><p>使用时应加入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> std::vector;<br></code></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h1 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h1><h2 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h2><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h1 id="类设计者的工具"><a href="#类设计者的工具" class="headerlink" title="类设计者的工具"></a>类设计者的工具</h1><h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><h2 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h2><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
